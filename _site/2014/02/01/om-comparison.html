<!DOCTYPE html>
<html>
  <head>
    <title>Om Comparison</title>
    <link href='http://fonts.googleapis.com/css?family=Arvo&v2' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Chivo' rel='stylesheet' type='text/css'>
    <link rel='stylesheet' href='/css/screen.css'></link>
    <link rel='stylesheet' href='/css/highlight.css'></link>
    <link rel='shortcut icon' type='image/ico' href='http://mcramm.com/favicon.png'></link>
  </head>
  <body>
    <div class='header'>
        <a class='header-text' href='/'>mcramm.com</a>
        <div class='navigation'>
            <a href='/'>About</a>
            <a href='/posts.html'>Posts</a>
            <a target='_blank' href='http://feeds.feedburner.com/mcramm'>Feed</a>
        </div>
    </div>
    <div class='content'>
    <h1>Om Comparison </h1>
    <p>In my <a href="http://mcramm.com/2014/01/26/react-intro.html">last post</a> I built a simple text manipulation widget with <a href="http://facebook.github.io/react/">React</a>. I recommend reading through that post first, before this one. As promised, I&#39;ve built the same widget in <a href="">Om</a>, a Clojurescript library that sits on top of React.</p>

<p>If you want to follow along, you&#39;ll need to install Leiningen and run:</p>
<div class='highlight'><pre><code class='bash'>    lein new mies-om om-intro
</code></pre></div>
<p><code>cd</code> into the new directory and make your <code>project.clj</code> look like the following:</p>
<div class='highlight'><pre><code class='clojure'>    <span class='p'>(</span><span class='kd'>defproject </span><span class='nv'>om-intro</span> <span class='s'>&quot;0.1.0-SNAPSHOT&quot;</span>
      <span class='ss'>:description</span> <span class='s'>&quot;FIXME: write this!&quot;</span>
      <span class='ss'>:url</span> <span class='s'>&quot;http://example.com/FIXME&quot;</span>
     
      <span class='ss'>:dependencies</span> <span class='p'>[[</span><span class='nv'>org.clojure/clojure</span> <span class='s'>&quot;1.5.1&quot;</span><span class='p'>]</span>
                     <span class='p'>[</span><span class='nv'>org.clojure/clojurescript</span> <span class='s'>&quot;0.0-2138&quot;</span><span class='p'>]</span>
                     <span class='p'>[</span><span class='nv'>org.clojure/core.async</span> <span class='s'>&quot;0.1.267.0-0d7780-alpha&quot;</span><span class='p'>]</span>
                     <span class='p'>[</span><span class='nv'>om</span> <span class='s'>&quot;0.3.1&quot;</span><span class='p'>]</span>
                     <span class='p'>[</span><span class='nv'>com.facebook/react</span> <span class='s'>&quot;0.8.0.1&quot;</span><span class='p'>]]</span>
     
      <span class='ss'>:plugins</span> <span class='p'>[[</span><span class='nv'>lein-cljsbuild</span> <span class='s'>&quot;1.0.1&quot;</span><span class='p'>]]</span>
     
      <span class='ss'>:source-paths</span> <span class='p'>[</span><span class='s'>&quot;src&quot;</span><span class='p'>]</span>
     
      <span class='ss'>:cljsbuild</span> <span class='p'>{</span>
        <span class='ss'>:builds</span> <span class='p'>[{</span><span class='ss'>:id</span> <span class='s'>&quot;dev&quot;</span>
                  <span class='ss'>:source-paths</span> <span class='p'>[</span><span class='s'>&quot;src&quot;</span><span class='p'>]</span>
                  <span class='ss'>:compiler</span> <span class='p'>{</span>
                    <span class='ss'>:output-to</span> <span class='s'>&quot;om_intro.js&quot;</span>
                    <span class='ss'>:output-dir</span> <span class='s'>&quot;out&quot;</span>
                    <span class='ss'>:optimizations</span> <span class='ss'>:none</span>
                    <span class='ss'>:source-map</span> <span class='nv'>true</span><span class='p'>}}]})</span>
</code></pre></div>
<p>You will also want to update your <code>index.html</code> look like this:</p>
<div class='highlight'><pre><code class='html'>    <span class='nt'>&lt;html&gt;</span>
        <span class='nt'>&lt;body&gt;</span>
            <span class='nt'>&lt;div</span> <span class='na'>id=</span><span class='s'>&quot;app&quot;</span><span class='nt'>&gt;&lt;/div&gt;</span>
            <span class='nt'>&lt;script </span><span class='na'>src=</span><span class='s'>&quot;http://fb.me/react-0.8.0.js&quot;</span><span class='nt'>&gt;&lt;/script&gt;</span>
            <span class='nt'>&lt;script </span><span class='na'>src=</span><span class='s'>&quot;out/goog/base.js&quot;</span> <span class='na'>type=</span><span class='s'>&quot;text/javascript&quot;</span><span class='nt'>&gt;&lt;/script&gt;</span>
            <span class='nt'>&lt;script </span><span class='na'>src=</span><span class='s'>&quot;om_intro.js&quot;</span> <span class='na'>type=</span><span class='s'>&quot;text/javascript&quot;</span><span class='nt'>&gt;&lt;/script&gt;</span>
            <span class='nt'>&lt;script </span><span class='na'>type=</span><span class='s'>&quot;text/javascript&quot;</span><span class='nt'>&gt;</span><span class='nx'>goog</span><span class='p'>.</span><span class='nx'>require</span><span class='p'>(</span><span class='s2'>&quot;om_intro.core&quot;</span><span class='p'>);</span><span class='nt'>&lt;/script&gt;</span>
        <span class='nt'>&lt;/body&gt;</span>
    <span class='nt'>&lt;/html&gt;</span>
</code></pre></div>
<p>Get any missing dependencies with <code>lein deps</code>, then build the project with <code>lein
cljsbuild once dev</code>. Open <code>index.html</code> in a browser and you should see the bare-bones example that comes with this template.</p>

<p>For the rest of this tutorial, I recommend running <code>lein cljsbuild auto dev</code> in a separate terminal. The first time the project gets built takes a second or two, but after the JVM has warmed up, it takes just milliseconds.</p>

<p>The snippets above are for a development build of the project. The final example I link to at the end of this post contains a release build, that generates a single JavaScript file.</p>

<p>With the setup out of the way we can start rebuilding this widget.</p>
<div class='highlight'><pre><code class='clojure'>    <span class='p'>(</span><span class='kd'>ns </span><span class='nv'>om-intro.core</span>
      <span class='p'>(</span><span class='ss'>:require</span> <span class='p'>[</span><span class='nv'>om.core</span> <span class='ss'>:as</span> <span class='nv'>om</span> <span class='ss'>:include-macros</span> <span class='nv'>true</span><span class='p'>]</span>
                <span class='p'>[</span><span class='nv'>om.dom</span> <span class='ss'>:as</span> <span class='nv'>dom</span> <span class='ss'>:include-macros</span> <span class='nv'>true</span><span class='p'>]))</span>

    <span class='p'>(</span><span class='k'>def </span><span class='nv'>app-state</span> <span class='p'>(</span><span class='nf'>atom</span> <span class='ss'>:text</span> <span class='s'>&quot;Some Text&quot;</span><span class='p'>))</span>

    <span class='p'>(</span><span class='kd'>defn </span><span class='nv'>my-widget</span> <span class='p'>[</span><span class='nv'>app</span> <span class='nv'>owner</span><span class='p'>]</span>
      <span class='p'>(</span><span class='nf'>reify</span>
        <span class='nv'>om/IRender</span>
        <span class='p'>(</span><span class='nf'>render</span> <span class='p'>[</span><span class='nv'>this</span><span class='p'>]</span>
          <span class='p'>(</span><span class='nf'>dom/div</span> <span class='nv'>nil</span> <span class='p'>(</span><span class='ss'>:text</span> <span class='nv'>app</span><span class='p'>)))))</span>

    <span class='p'>(</span><span class='nf'>om/root</span>
      <span class='nv'>app-state</span>
      <span class='nv'>my-widget</span>
      <span class='p'>(</span><span class='k'>. </span><span class='nv'>js/document</span> <span class='p'>(</span><span class='nf'>getElementById</span> <span class='s'>&quot;app&quot;</span><span class='p'>)))</span>
</code></pre></div>
<p>This is analogous to the first example in the React version; all we&#39;re doing is defining a component that renders a <code>div</code> containing the value of <code>:text</code> from our application state.</p>

<p>There are already a differences though. First, we&#39;ve moved all of our state into an atom. Components are given <em>cursors</em> into this application state that they can use to read/update.</p>

<p>Second, our <code>my-widget</code> component is returning a reified object that satisfies the <code>om/IRender</code> interface. The <code>render</code> method simply returns the aforementioned <code>div</code>.</p>

<p>You should see something like this:</p>
<div class='highlight example' id='ex1'> </div>
<p>Like our first example in the React version, this is pretty boring. Let&#39;s add in the text input.</p>

<p>We&#39;re going to be using <a href="https://github.com/clojure/core.async">core.async</a> at the edges of our components, wherever our users will be interacting with the various <code>input</code>s we&#39;ll eventually have.</p>

<p>Change the namespace declaration to the following:</p>
<div class='highlight'><pre><code class='clojure'>    <span class='p'>(</span><span class='kd'>ns </span><span class='nv'>om-intro.core</span>
      <span class='p'>(</span><span class='ss'>:require-macros</span> <span class='p'>[</span><span class='nv'>cljs.core.async.macros</span> <span class='ss'>:refer</span> <span class='p'>[</span><span class='nv'>go</span><span class='p'>]])</span>
      <span class='p'>(</span><span class='ss'>:require</span> <span class='p'>[</span><span class='nv'>om.core</span> <span class='ss'>:as</span> <span class='nv'>om</span> <span class='ss'>:include-macros</span> <span class='nv'>true</span><span class='p'>]</span>
                <span class='p'>[</span><span class='nv'>om.dom</span> <span class='ss'>:as</span> <span class='nv'>dom</span> <span class='ss'>:include-macros</span> <span class='nv'>true</span><span class='p'>]</span>
                <span class='p'>[</span><span class='nv'>cljs.core.async</span> <span class='ss'>:refer</span> <span class='p'>[</span><span class='nv'>put!</span> <span class='nv'>chan</span> <span class='nv'>&lt;!</span><span class='p'>]]))</span>
</code></pre></div>
<p>Then we&#39;ll update the widget. We&#39;re going to walk through this step-by-step in a minute, but here is what it should look like:</p>
<div class='highlight'><pre><code class='clojure'>    <span class='p'>(</span><span class='kd'>defn </span><span class='nv'>my-widget</span> <span class='p'>[</span><span class='nv'>app</span> <span class='nv'>owner</span><span class='p'>]</span>
      <span class='p'>(</span><span class='nf'>reify</span>
        <span class='nv'>om/IInitState</span>
        <span class='p'>(</span><span class='nf'>init-state</span> <span class='p'>[</span><span class='nv'>this</span><span class='p'>]</span>
          <span class='p'>{</span><span class='ss'>:comm</span> <span class='p'>{</span><span class='ss'>:string</span> <span class='p'>(</span><span class='nf'>chan</span><span class='p'>)}})</span>

        <span class='nv'>om/IWillMount</span>
        <span class='p'>(</span><span class='nf'>will-mount</span> <span class='p'>[</span><span class='nv'>this</span><span class='p'>]</span>
          <span class='p'>(</span><span class='k'>let </span><span class='p'>[{</span><span class='ss'>:keys</span> <span class='p'>[</span><span class='nv'>string</span><span class='p'>]}</span> <span class='p'>(</span><span class='nf'>om/get-state</span> <span class='nv'>owner</span> <span class='ss'>:comm</span><span class='p'>)]</span>
            <span class='p'>(</span><span class='nf'>go</span> <span class='p'>(</span><span class='nf'>while</span> <span class='nv'>true</span>
                  <span class='p'>(</span><span class='k'>let </span><span class='p'>[</span><span class='nv'>value</span> <span class='p'>(</span><span class='nf'>&lt;!</span> <span class='nv'>string</span><span class='p'>)]</span>
                    <span class='p'>(</span><span class='nf'>om/transact!</span> <span class='nv'>app</span> <span class='ss'>:text</span> <span class='p'>(</span><span class='k'>fn </span><span class='p'>[</span><span class='nv'>_</span><span class='p'>]</span> <span class='nv'>value</span><span class='p'>)))))))</span>

        <span class='nv'>om/IRenderState</span>
        <span class='p'>(</span><span class='nf'>render-state</span> <span class='p'>[</span><span class='nv'>this</span> <span class='p'>{</span><span class='ss'>:keys</span> <span class='p'>[</span><span class='nv'>comm</span><span class='p'>]}]</span>
          <span class='p'>(</span><span class='nf'>dom/div</span> <span class='nv'>nil</span>
                   <span class='p'>(</span><span class='nf'>dom/input</span> <span class='o'>#</span><span class='nv'>js</span> <span class='p'>{</span><span class='ss'>:type</span> <span class='s'>&quot;text&quot;</span>
                                   <span class='ss'>:ref</span> <span class='s'>&quot;text&quot;</span>
                                   <span class='ss'>:value</span> <span class='p'>(</span><span class='ss'>:text</span> <span class='nv'>app</span><span class='p'>)</span>
                                   <span class='ss'>:onChange</span> <span class='o'>#</span><span class='p'>(</span><span class='nf'>put!</span>
                                                <span class='p'>(</span><span class='ss'>:string</span> <span class='nv'>comm</span><span class='p'>)</span>
                                                <span class='p'>(</span><span class='nb'>-&gt; </span><span class='p'>(</span><span class='nf'>om/get-node</span> <span class='nv'>owner</span> <span class='s'>&quot;text&quot;</span><span class='p'>)</span>
                                                    <span class='nv'>.-value</span><span class='p'>))})</span>

                   <span class='p'>(</span><span class='nf'>dom/div</span> <span class='nv'>nil</span> <span class='p'>(</span><span class='ss'>:text</span> <span class='nv'>app</span><span class='p'>))))))</span>
</code></pre></div>
<p>We&#39;ve changed our widget to satisfy a few more Om interfaces that take advantage of the <a href="http://facebook.github.io/react/docs/component-specs.html">React life cycles</a>.</p>

<p>The first is <code>om/IInitState</code> which sets up some initial, local state for the component. Here we are creating a map with a channel assigned to the <code>:string</code> key. <code>init-state</code> is called once on a component.</p>

<p>In <code>om/IWillMount</code>, we setup a go loop that blocks on the channel assigned to <code>:string</code> earlier, then sets the <code>:text</code> attribute in our application state to the value we get off of that channel. Once it&#39;s done it goes back to waiting on the channel.</p>

<blockquote>
<p>If you&#39;re new to Clojure, then the destructuring we do in the <code>let</code> binding can be a little confusing. The gist of what we&#39;re doing is creating a local <code>string</code> variable for our go block that is the key a map returned by <code>(om/get-state owner :comm)</code>. In other words, it takes the map we created earlier and creates a local variable that is assigned the value of the <code>:string</code> key.</p>
</blockquote>

<p>We use <code>om/trasact!</code> here since updating an atom needs to occur within a transaction. We could have also used <code>swap!</code> here to modify the <code>atom</code> manually.</p>

<p><code>will-mount</code> is called once, before the component is mounted into the DOM.</p>

<p>Finally, we&#39;ve changed <code>om/IRender</code> to <code>om/IRenderState</code>. Every component needs to satisfy one of these interfaces, but not both. The difference between the two is that <code>IRenderState</code> is passed the component state as it&#39;s second argument. We need it so that we can have access to the channel we created earlier.</p>

<p>Finally we create the <code>input</code>:</p>
<div class='highlight'><pre><code class='clojure'>    <span class='p'>(</span><span class='nf'>dom/input</span> <span class='o'>#</span><span class='nv'>js</span> <span class='p'>{</span><span class='ss'>:type</span> <span class='s'>&quot;text&quot;</span>
                    <span class='ss'>:ref</span> <span class='s'>&quot;text&quot;</span>
                    <span class='ss'>:value</span> <span class='p'>(</span><span class='ss'>:text</span> <span class='nv'>app</span><span class='p'>)</span>
                    <span class='ss'>:onChange</span> <span class='o'>#</span><span class='p'>(</span><span class='nf'>put!</span>
                                <span class='p'>(</span><span class='ss'>:string</span> <span class='nv'>comm</span><span class='p'>)</span>
                                <span class='p'>(</span><span class='nb'>-&gt; </span><span class='p'>(</span><span class='nf'>om/get-node</span> <span class='nv'>owner</span> <span class='s'>&quot;text&quot;</span><span class='p'>)</span>
                                    <span class='nv'>.-value</span><span class='p'>))})</span>
</code></pre></div>
<p>The element is actually only taking a single argument, though it looks like two. <code>#js</code> is a reader literal for Clojurscript that transforms the following object into literal JavaScript object. The map that we pass is setting some attributes on the component. In this case, we want a text input that contains the value of the <code>:text</code> key from our application state. We assign it the ref <code>text</code> so that we can refer to it from <code>onChange</code> callback.</p>

<p>This callback is really simple, and is one of the reasons why core.async is so attractive. All it does is take the value of the <code>text</code> node and put it onto the <code>string</code> channel.</p>

<p>If you&#39;ve been following along, then you should see the following:</p>
<div class='highlight example' id='ex2'> </div>
<p>The next step is to add in the text-size slider. First, let&#39;s add the size to our application state:</p>
<div class='highlight'><pre><code class='clojure'>    <span class='p'>(</span><span class='k'>def </span><span class='nv'>app-state</span> <span class='p'>(</span><span class='nf'>atom</span> <span class='p'>{</span><span class='ss'>:text</span> <span class='s'>&quot;Some Text&quot;</span>
                          <span class='ss'>:size</span> <span class='mi'>15</span><span class='p'>}))</span>
</code></pre></div>
<p>Next we&#39;ll create another channel for manipulating this size:</p>
<div class='highlight'><pre><code class='clojure'>    <span class='nv'>om/IInitState</span>
    <span class='p'>(</span><span class='nf'>init-state</span> <span class='p'>[</span><span class='nv'>this</span><span class='p'>]</span>
      <span class='p'>{</span><span class='ss'>:comm</span> <span class='p'>{</span><span class='ss'>:string</span> <span class='p'>(</span><span class='nf'>chan</span><span class='p'>)</span>
              <span class='ss'>:size</span> <span class='p'>(</span><span class='nf'>chan</span><span class='p'>)}})</span>
</code></pre></div>
<p>We&#39;ll create another go block to update <code>:size</code> whenever we get a value off of this channel:</p>
<div class='highlight'><pre><code class='clojure'>    <span class='nv'>om/IWillMount</span>
    <span class='p'>(</span><span class='nf'>will-mount</span> <span class='p'>[</span><span class='nv'>this</span><span class='p'>]</span>
      <span class='p'>(</span><span class='k'>let </span><span class='p'>[{</span><span class='ss'>:keys</span> <span class='p'>[</span><span class='nv'>string</span> <span class='nv'>size</span><span class='p'>]</span> <span class='ss'>:as</span> <span class='nv'>comm</span><span class='p'>}</span> <span class='p'>(</span><span class='nf'>om/get-state</span> <span class='nv'>owner</span> <span class='ss'>:comm</span><span class='p'>)]</span>
        <span class='p'>(</span><span class='nf'>go</span> <span class='p'>(</span><span class='nf'>while</span> <span class='nv'>true</span>
              <span class='p'>(</span><span class='k'>let </span><span class='p'>[</span><span class='nv'>value</span> <span class='p'>(</span><span class='nf'>&lt;!</span> <span class='nv'>string</span><span class='p'>)]</span>
                <span class='p'>(</span><span class='nf'>om/transact!</span> <span class='nv'>app</span> <span class='ss'>:text</span> <span class='p'>(</span><span class='k'>fn </span><span class='p'>[</span><span class='nv'>_</span><span class='p'>]</span> <span class='nv'>value</span><span class='p'>)))))</span>
        <span class='p'>(</span><span class='nf'>go</span> <span class='p'>(</span><span class='nf'>while</span> <span class='nv'>true</span>
              <span class='p'>(</span><span class='k'>let </span><span class='p'>[</span><span class='nv'>value</span> <span class='p'>(</span><span class='nf'>&lt;!</span> <span class='nv'>size</span><span class='p'>)]</span>
                <span class='p'>(</span><span class='nf'>om/transact!</span> <span class='nv'>app</span> <span class='ss'>:size</span> <span class='p'>(</span><span class='k'>fn </span><span class='p'>[</span><span class='nv'>_</span><span class='p'>]</span> <span class='nv'>value</span><span class='p'>)))))))</span>
</code></pre></div>
<p>And then we&#39;ll add the input. Since we&#39;re getting the value off in the input in a similar way as before, I created a small helper to do this. I would place this function at the top of your source file, underneath the atom:</p>
<div class='highlight'><pre><code class='clojure'>    <span class='p'>(</span><span class='kd'>defn </span><span class='nv'>get-value</span> <span class='p'>[</span><span class='nv'>owner</span> <span class='nv'>ref</span><span class='p'>]</span>
      <span class='p'>(</span><span class='nb'>-&gt; </span><span class='p'>(</span><span class='nf'>om/get-node</span> <span class='nv'>owner</span> <span class='nv'>ref</span><span class='p'>)</span>
          <span class='nv'>.-value</span><span class='p'>))</span>
</code></pre></div><div class='highlight'><pre><code class='clojure'>    <span class='p'>(</span><span class='nf'>dom/div</span> <span class='nv'>nil</span>
            <span class='p'>(</span><span class='nf'>dom/input</span> <span class='o'>#</span><span class='nv'>js</span> <span class='p'>{</span><span class='ss'>:type</span> <span class='s'>&quot;range&quot;</span>
                            <span class='ss'>:min</span> <span class='mi'>10</span>
                            <span class='ss'>:max</span> <span class='mi'>50</span>
                            <span class='ss'>:step</span> <span class='mf'>0.2</span>
                            <span class='ss'>:ref</span> <span class='s'>&quot;size&quot;</span>
                            <span class='ss'>:value</span> <span class='p'>(</span><span class='ss'>:size</span> <span class='nv'>app</span><span class='p'>)</span>
                            <span class='ss'>:onChange</span> <span class='o'>#</span><span class='p'>(</span><span class='nf'>put!</span>
                                        <span class='p'>(</span><span class='ss'>:size</span> <span class='nv'>comm</span><span class='p'>)</span>
                                        <span class='p'>(</span><span class='nf'>get-value</span> <span class='nv'>owner</span> <span class='s'>&quot;size&quot;</span><span class='p'>))})</span>
            <span class='p'>(</span><span class='nf'>dom/label</span> <span class='nv'>nil</span> <span class='p'>(</span><span class='nb'>str </span><span class='p'>(</span><span class='ss'>:size</span> <span class='nv'>app</span><span class='p'>)</span> <span class='s'>&quot;px&quot;</span><span class='p'>)))</span>
</code></pre></div>
<p>Note that you may want to update the text input as well.</p>

<p>Finally, we wan&#39;t to modify our <code>div</code> to have it&#39;s font-size restyled whenever this changes. Right now it looks like this:</p>
<div class='highlight'><pre><code class='clojure'>    <span class='p'>(</span><span class='nf'>dom/div</span> <span class='nv'>nil</span> <span class='p'>(</span><span class='ss'>:text</span> <span class='nv'>app</span><span class='p'>))</span>
</code></pre></div>
<p>Change it to this:</p>
<div class='highlight'><pre><code class='clojure'>    <span class='p'>(</span><span class='nf'>dom/div</span> <span class='o'>#</span><span class='nv'>js</span> <span class='p'>{</span><span class='ss'>:style</span> <span class='o'>#</span><span class='nv'>js</span> <span class='p'>{</span><span class='ss'>:font-size</span> <span class='p'>(</span><span class='nb'>str </span><span class='p'>(</span><span class='ss'>:size</span> <span class='nv'>app</span><span class='p'>)</span> <span class='s'>&quot;px&quot;</span><span class='p'>)}}</span>
          <span class='p'>(</span><span class='ss'>:text</span> <span class='nv'>app</span><span class='p'>))</span>
</code></pre></div>
<p>Again, <code>#js</code> turns the following object into a JavaScript object. It&#39;s shallow, so we need to do it twice to set <code>:style</code> correctly.</p>

<p>You should see this now:</p>
<div class='highlight example' id='ex3'> </div>
<p>Now for the color sliders. First, we&#39;ll add in the new state:</p>
<div class='highlight'><pre><code class='clojure'>    <span class='p'>(</span><span class='k'>def </span><span class='nv'>app-state</span> <span class='p'>(</span><span class='nf'>atom</span> <span class='p'>{</span><span class='ss'>:text</span> <span class='s'>&quot;Some Text&quot;</span>
                          <span class='ss'>:size</span> <span class='mi'>15</span>
                          <span class='ss'>:colors</span> <span class='p'>{</span><span class='ss'>:red</span> <span class='mi'>0</span>
                                   <span class='ss'>:green</span> <span class='mi'>0</span>
                                   <span class='ss'>:blue</span> <span class='mi'>0</span><span class='p'>}}))</span>
</code></pre></div>
<p>As in the React widget, we&#39;ll create a more general <code>color-slider</code>:</p>
<div class='highlight'><pre><code class='clojure'>    <span class='p'>(</span><span class='kd'>defn </span><span class='nv'>color-slider</span> <span class='p'>[</span><span class='nv'>colors</span> <span class='nv'>owner</span> <span class='p'>{</span><span class='ss'>:keys</span> <span class='p'>[</span><span class='nv'>label</span> <span class='nv'>onChange</span> <span class='nv'>color-key</span><span class='p'>]}]</span>
      <span class='p'>(</span><span class='nf'>reify</span>
        <span class='nv'>om/IRenderState</span>
        <span class='p'>(</span><span class='nf'>render-state</span> <span class='p'>[</span><span class='nv'>this</span> <span class='p'>{</span><span class='ss'>:keys</span> <span class='p'>[</span><span class='nv'>comm</span><span class='p'>]}]</span>
          <span class='p'>(</span><span class='nf'>dom/div</span> <span class='nv'>nil</span>
                   <span class='p'>(</span><span class='nf'>dom/input</span> <span class='o'>#</span><span class='nv'>js</span> <span class='p'>{</span><span class='ss'>:type</span> <span class='s'>&quot;range&quot;</span>
                                   <span class='ss'>:min</span> <span class='mi'>0</span>
                                   <span class='ss'>:max</span> <span class='mi'>255</span>
                                   <span class='ss'>:step</span> <span class='mi'>1</span>
                                   <span class='ss'>:ref</span> <span class='s'>&quot;color&quot;</span>
                                   <span class='ss'>:value</span> <span class='p'>(</span><span class='nf'>color-key</span> <span class='nv'>colors</span><span class='p'>)</span>
                                   <span class='ss'>:onChange</span> <span class='o'>#</span><span class='p'>(</span><span class='nf'>onChange</span> <span class='nv'>color-key</span> <span class='nv'>owner</span><span class='p'>)})</span>
                   <span class='p'>(</span><span class='nf'>dom/label</span> <span class='nv'>nil</span> <span class='p'>(</span><span class='nb'>str </span><span class='nv'>label</span> <span class='s'>&quot;: &quot;</span> <span class='p'>(</span><span class='nf'>color-key</span> <span class='nv'>colors</span><span class='p'>)))))))</span>
</code></pre></div>
<p>The important bit here is extra map of attributes we&#39;ll be passing to this component. We&#39;re going to give it a label, a color key to pull from the application state, and an onChange function.</p>

<p>Next we&#39;ll create a channel for the changing colors:</p>
<div class='highlight'><pre><code class='clojure'>    <span class='nv'>om/IInitState</span>
    <span class='p'>(</span><span class='nf'>init-state</span> <span class='p'>[</span><span class='nv'>this</span><span class='p'>]</span>
      <span class='p'>{</span><span class='ss'>:comm</span> <span class='p'>{</span><span class='ss'>:string</span> <span class='p'>(</span><span class='nf'>chan</span><span class='p'>)</span>
              <span class='ss'>:size</span> <span class='p'>(</span><span class='nf'>chan</span><span class='p'>)</span>
              <span class='ss'>:colors</span> <span class='p'>(</span><span class='nf'>chan</span><span class='p'>)}})</span>
</code></pre></div>
<p>And a go block:</p>
<div class='highlight'><pre><code class='clojure'>    <span class='p'>(</span><span class='nf'>go</span> <span class='p'>(</span><span class='nf'>while</span> <span class='nv'>true</span>
          <span class='p'>(</span><span class='k'>let </span><span class='p'>[[</span><span class='nv'>c</span> <span class='nv'>value</span><span class='p'>]</span> <span class='p'>(</span><span class='nf'>&lt;!</span> <span class='nv'>colors</span><span class='p'>)]</span>
            <span class='p'>(</span><span class='nf'>om/update!</span> <span class='nv'>app</span> <span class='nv'>assoc-in</span> <span class='p'>[</span><span class='ss'>:colors</span> <span class='nv'>c</span><span class='p'>]</span> <span class='nv'>value</span><span class='p'>))))))</span>
</code></pre></div>
<p>This looks slightly different than the previous go blocks because we&#39;re dealing with a map of colors in the application state instead of a straight value.</p>
<div class='highlight'><pre><code class='clojure'>    <span class='p'>(</span><span class='k'>let </span><span class='p'>[</span><span class='nv'>putfn</span> <span class='p'>(</span><span class='k'>fn </span><span class='p'>[</span><span class='nv'>k</span> <span class='nv'>o</span><span class='p'>]</span>
                 <span class='p'>(</span><span class='nf'>put!</span> <span class='p'>(</span><span class='ss'>:colors</span> <span class='nv'>comm</span><span class='p'>)</span> <span class='p'>[</span><span class='nv'>k</span> <span class='p'>(</span><span class='nf'>get-value</span> <span class='nv'>o</span> <span class='s'>&quot;color&quot;</span><span class='p'>)]))]</span>
        <span class='p'>(</span><span class='nb'>apply </span><span class='nv'>dom/div</span> <span class='nv'>nil</span>
             <span class='p'>(</span><span class='nb'>map </span><span class='p'>(</span><span class='k'>fn </span><span class='p'>[[</span><span class='nv'>label</span> <span class='nv'>color-key</span><span class='p'>]]</span>
                    <span class='p'>(</span><span class='nf'>om/build</span> <span class='nv'>color-slider</span>
                              <span class='p'>(</span><span class='ss'>:colors</span> <span class='nv'>app</span><span class='p'>)</span>
                              <span class='p'>{</span><span class='ss'>:opts</span> <span class='p'>{</span><span class='ss'>:label</span> <span class='nv'>label</span>
                                      <span class='ss'>:color-key</span> <span class='nv'>color-key</span>
                                      <span class='ss'>:onChange</span> <span class='nv'>putfn</span><span class='p'>}}))</span>
                  <span class='p'>[[</span><span class='s'>&quot;Red&quot;</span> <span class='ss'>:red</span><span class='p'>]</span> <span class='p'>[</span><span class='s'>&quot;Green&quot;</span> <span class='ss'>:green</span><span class='p'>]</span> <span class='p'>[</span><span class='s'>&quot;Blue&quot;</span> <span class='ss'>:blue</span><span class='p'>]])))</span>
</code></pre></div>
<p>Next we&#39;ll add the inputs right below the text size slider. We use some high level functions here to avoid having to write three calls to <code>om/build</code>.</p>

<p>Finally we can modify the <code>div</code> to re-color our text:</p>
<div class='highlight'><pre><code class='clojure'>    <span class='p'>(</span><span class='k'>let </span><span class='p'>[</span><span class='nv'>size</span> <span class='p'>(</span><span class='ss'>:size</span> <span class='nv'>app</span><span class='p'>)</span>
          <span class='nv'>text</span> <span class='p'>(</span><span class='ss'>:text</span> <span class='nv'>app</span><span class='p'>)</span>
          <span class='p'>{</span><span class='ss'>:keys</span> <span class='p'>[</span><span class='nv'>red</span> <span class='nv'>green</span> <span class='nv'>blue</span><span class='p'>]}</span> <span class='p'>(</span><span class='ss'>:colors</span> <span class='nv'>app</span><span class='p'>)]</span>
     <span class='p'>(</span><span class='nf'>dom/div</span> <span class='o'>#</span><span class='nv'>js</span> <span class='p'>{</span><span class='ss'>:style</span> <span class='o'>#</span><span class='nv'>js</span> <span class='p'>{</span><span class='ss'>:font-size</span> <span class='p'>(</span><span class='nb'>str </span><span class='nv'>size</span> <span class='s'>&quot;px&quot;</span><span class='p'>)</span>
                               <span class='ss'>:color</span> <span class='p'>(</span><span class='nb'>str </span><span class='s'>&quot;rgb(&quot;</span> <span class='nv'>red</span> <span class='s'>&quot;,&quot;</span> <span class='nv'>green</span> <span class='s'>&quot;,&quot;</span> <span class='nv'>blue</span> <span class='s'>&quot;)&quot;</span><span class='p'>)}}</span>
              <span class='nv'>text</span><span class='p'>))))))</span>
</code></pre></div>
<p>Here is the final product, for the second time:</p>
<div class='highlight example' id='final'> </div>
<p>The full source for this example can be found <a href="https://gist.github.com/mcramm/8755952">here</a>.</p>

<p>Om is still very new, and changing rapidly. If you&#39;re interested, then I recommend running through the <a href="https://github.com/swannodette/om/wiki/Tutorial">Tutorial</a> in LightTable.</p>
<script src='/js/om-intro.js' type='text/javascript'><![CDATA[]]></script>
</div>
<div class='respond'>
    Want to comment? Send a message to <a href='https://twitter.com/intent/tweet?text=@cramm'>@cramm</a> on Twitter.
</div>


    <div class='footer-wrap'>
        <div class='footer'>
            <div class='copyright'>&copy; 2014 Michael Cramm</div>
        </div>
    </div>
</body>
</html>
