<!doctype html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mcrammm.com</title>
    <link href='https://fonts.googleapis.com/css?family=Droid+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/css/main.css">
    <link href="http://mcramm.com//index.xml" rel="alternate" type="application/rss+xml" title="mcrammm.com" />
    <meta name="title" content="http://mcramm.com/">
    <link rel="canonical" href="http://mcramm.com/">
    <meta property="og:title" content="mcrammm.com"/>
    <meta property="og:url" content="http://mcramm.com/"/>
    <meta property="og:site_name" content="mcrammm.com">
    <style>
        .container {
            max-width:1155px;
        }

        pre {
            white-space: pre;
            overflow: scroll;
            width:inherit;
            word-wrap: normal;
            word-break: normal;
        }

        article blockquote {
            background-color: whitesmoke;
            font-size: 0.85em;
            border-left: 5px solid #eeeeee;
            margin: 0 0 20px 0;
            padding: 10px 20px;
        }

        article blockquote p {
            font-size: inherit;
            line-height: inherit;
            color: inherit;
            font-weight: inherit;
        }
    </style>
</head>
<body>
    
<section class="site-nav">
    <header>
        <nav id="navigation">
            <a href="/" class="home">About</a>
            <a href="/post" class="post">Posts</a>
        </nav>
    </header>
</section>

<article>
    <div class="container">
        <header>
            <div class="meta">
                <time pubdate datetime="2014-02-01" title="2014-02-01">February 01, 2014</time>
            </div>
            <h1 class="title">Om Comparison</h1>
            <h2 class="subtitle"></h2>
        </header>

        <section>
            <p>In my <a href="http://mcramm.com/2014/01/26/react-intro.html">last post</a> I built a simple text manipulation widget with <a href="http://facebook.github.io/react/">React</a>.
I recommend reading through that post first, before this one.
As promised, I&rsquo;ve built the same widget in
<a href="https://github.com/swannodette/om">Om</a>, a ClojureScript library that
sits on top of React.</p>

<p></p>

<p>If you want to follow along, you&rsquo;ll need to install Leiningen and run:</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">    lein new mies-om om-intro
</code></pre></div>


<p><code>cd</code> into the new directory and make your <code>project.clj</code> look like the following:
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure">    <span class="p">(</span><span class="kd">defproject </span><span class="nv">om-intro</span> <span class="s">&quot;0.1.0-SNAPSHOT&quot;</span>
      <span class="ss">:description</span> <span class="s">&quot;FIXME: write this!&quot;</span>
      <span class="ss">:url</span> <span class="s">&quot;http://example.com/FIXME&quot;</span>

      <span class="ss">:dependencies</span> <span class="p">[[</span><span class="nv">org.clojure/clojure</span> <span class="s">&quot;1.5.1&quot;</span><span class="p">]</span>
                     <span class="p">[</span><span class="nv">org.clojure/clojurescript</span> <span class="s">&quot;0.0-2138&quot;</span><span class="p">]</span>
                     <span class="p">[</span><span class="nv">org.clojure/core.async</span> <span class="s">&quot;0.1.267.0-0d7780-alpha&quot;</span><span class="p">]</span>
                     <span class="p">[</span><span class="nv">om</span> <span class="s">&quot;0.3.1&quot;</span><span class="p">]</span>
                     <span class="p">[</span><span class="nv">com.facebook/react</span> <span class="s">&quot;0.8.0.1&quot;</span><span class="p">]]</span>

      <span class="ss">:plugins</span> <span class="p">[[</span><span class="nv">lein-cljsbuild</span> <span class="s">&quot;1.0.1&quot;</span><span class="p">]]</span>

      <span class="ss">:source-paths</span> <span class="p">[</span><span class="s">&quot;src&quot;</span><span class="p">]</span>

      <span class="ss">:cljsbuild</span> <span class="p">{</span>
        <span class="ss">:builds</span> <span class="p">[{</span><span class="ss">:id</span> <span class="s">&quot;dev&quot;</span>
                  <span class="ss">:source-paths</span> <span class="p">[</span><span class="s">&quot;src&quot;</span><span class="p">]</span>
                  <span class="ss">:compiler</span> <span class="p">{</span>
                    <span class="ss">:output-to</span> <span class="s">&quot;om_intro.js&quot;</span>
                    <span class="ss">:output-dir</span> <span class="s">&quot;out&quot;</span>
                    <span class="ss">:optimizations</span> <span class="ss">:none</span>
                    <span class="ss">:source-map</span> <span class="nv">true</span><span class="p">}}]})</span>
</code></pre></div>
</p>

<p>You will also want to update your <code>index.html</code> look like this:</p>

<div class="highlight"><pre><code class="language-html" data-lang="html">    <span class="nt">&lt;html&gt;</span>
        <span class="nt">&lt;body&gt;</span>
            <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;app&quot;</span><span class="nt">&gt;&lt;/div&gt;</span>
            <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&quot;http://fb.me/react-0.8.0.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
            <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&quot;out/goog/base.js&quot;</span> <span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
            <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&quot;om_intro.js&quot;</span> <span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
            <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span><span class="nt">&gt;</span><span class="nx">goog</span><span class="p">.</span><span class="nx">require</span><span class="p">(</span><span class="s2">&quot;om_intro.core&quot;</span><span class="p">);</span><span class="nt">&lt;/script&gt;</span>
        <span class="nt">&lt;/body&gt;</span>
    <span class="nt">&lt;/html&gt;</span>
</code></pre></div>


<p>Get any missing dependencies with <code>lein deps</code>, then build the project with <code>lein
cljsbuild once dev</code>. Open <code>index.html</code> in a browser and you should see the
bare-bones example that comes with this template.</p>

<p>For the rest of this tutorial, I recommend running <code>lein cljsbuild auto dev</code> in
a separate terminal. The first time the project gets built takes a second or
two, but after the JVM has warmed up, it takes just milliseconds.</p>

<p>The snippets above are for a development build of the project. The final example
I link to at the end of this post contains a release build, that generates a
single JavaScript file.</p>

<p>With the setup out of the way we can start rebuilding this widget.</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure">    <span class="p">(</span><span class="kd">ns </span><span class="nv">om-intro.core</span>
      <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">om.core</span> <span class="ss">:as</span> <span class="nv">om</span> <span class="ss">:include-macros</span> <span class="nv">true</span><span class="p">]</span>
                <span class="p">[</span><span class="nv">om.dom</span> <span class="ss">:as</span> <span class="nv">dom</span> <span class="ss">:include-macros</span> <span class="nv">true</span><span class="p">]))</span>

    <span class="p">(</span><span class="k">def </span><span class="nv">app-state</span> <span class="p">(</span><span class="nf">atom</span> <span class="p">{</span><span class="ss">:text</span> <span class="s">&quot;Some Text&quot;</span><span class="p">}))</span>

    <span class="p">(</span><span class="kd">defn </span><span class="nv">my-widget</span> <span class="p">[</span><span class="nv">app</span> <span class="nv">owner</span><span class="p">]</span>
      <span class="p">(</span><span class="nf">reify</span>
        <span class="nv">om/IRender</span>
        <span class="p">(</span><span class="nf">render</span> <span class="p">[</span><span class="nv">this</span><span class="p">]</span>
          <span class="p">(</span><span class="nf">dom/div</span> <span class="nv">nil</span> <span class="p">(</span><span class="ss">:text</span> <span class="nv">app</span><span class="p">)))))</span>

    <span class="p">(</span><span class="nf">om/root</span>
      <span class="nv">app-state</span>
      <span class="nv">my-widget</span>
      <span class="p">(</span><span class="k">. </span><span class="nv">js/document</span> <span class="p">(</span><span class="nf">getElementById</span> <span class="s">&quot;app&quot;</span><span class="p">)))</span>
</code></pre></div>


<p>This is analogous to the first example in the React version; all we&rsquo;re doing is
defining a component that renders a <code>div</code> containing the value of <code>:text</code> from
our application state.</p>

<p>There are already a differences though. First, we&rsquo;ve moved all of our state
into an atom. Components are given <em>cursors</em> into this application state that
they can use to read/update.</p>

<p>Second, our <code>my-widget</code> component is returning a reified object that satisfies
the <code>om/IRender</code> interface. The <code>render</code> method simply returns the
aforementioned <code>div</code>.</p>

<p>You should see something like this:</p>

<div class='highlight example' id="ex1"> </div>

<p>Like our first example in the React version, this is pretty boring. Let&rsquo;s add
in the text input.</p>

<p>We&rsquo;re going to be using <a href="https://github.com/clojure/core.async">core.async</a> at
the edges of our components, wherever our users will be interacting with the
various <code>input</code>s we&rsquo;ll eventually have.</p>

<p>Change the namespace declaration to the following:</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure">    <span class="p">(</span><span class="kd">ns </span><span class="nv">om-intro.core</span>
      <span class="p">(</span><span class="ss">:require-macros</span> <span class="p">[</span><span class="nv">cljs.core.async.macros</span> <span class="ss">:refer</span> <span class="p">[</span><span class="nv">go</span><span class="p">]])</span>
      <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">om.core</span> <span class="ss">:as</span> <span class="nv">om</span> <span class="ss">:include-macros</span> <span class="nv">true</span><span class="p">]</span>
                <span class="p">[</span><span class="nv">om.dom</span> <span class="ss">:as</span> <span class="nv">dom</span> <span class="ss">:include-macros</span> <span class="nv">true</span><span class="p">]</span>
                <span class="p">[</span><span class="nv">cljs.core.async</span> <span class="ss">:refer</span> <span class="p">[</span><span class="nv">put!</span> <span class="nv">chan</span> <span class="nv">&lt;!</span><span class="p">]]))</span>
</code></pre></div>


<p>Then we&rsquo;ll update the widget. We&rsquo;re going to walk through this step-by-step in
a minute, but here is what it should look like:</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure">    <span class="p">(</span><span class="kd">defn </span><span class="nv">my-widget</span> <span class="p">[</span><span class="nv">app</span> <span class="nv">owner</span><span class="p">]</span>
      <span class="p">(</span><span class="nf">reify</span>
        <span class="nv">om/IInitState</span>
        <span class="p">(</span><span class="nf">init-state</span> <span class="p">[</span><span class="nv">this</span><span class="p">]</span>
          <span class="p">{</span><span class="ss">:comm</span> <span class="p">{</span><span class="ss">:string</span> <span class="p">(</span><span class="nf">chan</span><span class="p">)}})</span>

        <span class="nv">om/IWillMount</span>
        <span class="p">(</span><span class="nf">will-mount</span> <span class="p">[</span><span class="nv">this</span><span class="p">]</span>
          <span class="p">(</span><span class="k">let </span><span class="p">[{</span><span class="ss">:keys</span> <span class="p">[</span><span class="nv">string</span><span class="p">]}</span> <span class="p">(</span><span class="nf">om/get-state</span> <span class="nv">owner</span> <span class="ss">:comm</span><span class="p">)]</span>
            <span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="nf">while</span> <span class="nv">true</span>
                  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">value</span> <span class="p">(</span><span class="nf">&lt;!</span> <span class="nv">string</span><span class="p">)]</span>
                    <span class="p">(</span><span class="nf">om/transact!</span> <span class="nv">app</span> <span class="ss">:text</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="nv">value</span><span class="p">)))))))</span>

        <span class="nv">om/IRenderState</span>
        <span class="p">(</span><span class="nf">render-state</span> <span class="p">[</span><span class="nv">this</span> <span class="p">{</span><span class="ss">:keys</span> <span class="p">[</span><span class="nv">comm</span><span class="p">]}]</span>
          <span class="p">(</span><span class="nf">dom/div</span> <span class="nv">nil</span>
                   <span class="p">(</span><span class="nf">dom/input</span> <span class="o">#</span><span class="nv">js</span> <span class="p">{</span><span class="ss">:type</span> <span class="s">&quot;text&quot;</span>
                                   <span class="ss">:ref</span> <span class="s">&quot;text&quot;</span>
                                   <span class="ss">:value</span> <span class="p">(</span><span class="ss">:text</span> <span class="nv">app</span><span class="p">)</span>
                                   <span class="ss">:onChange</span> <span class="o">#</span><span class="p">(</span><span class="nf">put!</span>
                                                <span class="p">(</span><span class="ss">:string</span> <span class="nv">comm</span><span class="p">)</span>
                                                <span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">om/get-node</span> <span class="nv">owner</span> <span class="s">&quot;text&quot;</span><span class="p">)</span>
                                                    <span class="nv">.-value</span><span class="p">))})</span>

                   <span class="p">(</span><span class="nf">dom/div</span> <span class="nv">nil</span> <span class="p">(</span><span class="ss">:text</span> <span class="nv">app</span><span class="p">))))))</span>
</code></pre></div>


<p>We&rsquo;ve changed our widget to satisfy a few more Om interfaces that take
advantage of the <a href="http://facebook.github.io/react/docs/component-specs.html">React life cycles</a>.</p>

<p>The first is <code>om/IInitState</code> which sets up some initial, local state for the
component. Here we are creating a map with a channel assigned to the <code>:string</code>
key. <code>init-state</code> is called once on a component.</p>

<p>In <code>om/IWillMount</code>, we setup a go loop that blocks on the channel assigned to
<code>:string</code> earlier, then sets the <code>:text</code> attribute in our application state to
the value we get off of that channel. Once it&rsquo;s done it goes back to waiting on
the channel.</p>

<blockquote>
<p>If you&rsquo;re new to Clojure, then the destructuring we do in the <code>let</code> binding can
be a little confusing. The gist of what we&rsquo;re doing is creating a local
<code>string</code> variable for our go block that is based on a key in the map returned by
<code>(om/get-state owner :comm)</code>. In other words, it takes the map we created
earlier and creates a local variable that is assigned the value of the
<code>:string</code> key.</p>
</blockquote>

<p>We use <code>om/transact!</code> here since updating an atom needs to occur within a
transaction. We could have also used <code>swap!</code> here to modify the <code>atom</code> manually.</p>

<p><code>will-mount</code> is called once, before the component is mounted into the DOM.</p>

<p>Finally, we&rsquo;ve changed <code>om/IRender</code> to <code>om/IRenderState</code>. Every component needs
to satisfy one of these interfaces, but not both. The difference between the two
is that <code>IRenderState</code> is passed the component state as it&rsquo;s second argument. We
need it so that we can have access to the channel we created earlier.</p>

<p>Finally we create the <code>input</code>:</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure">    <span class="p">(</span><span class="nf">dom/input</span> <span class="o">#</span><span class="nv">js</span> <span class="p">{</span><span class="ss">:type</span> <span class="s">&quot;text&quot;</span>
                    <span class="ss">:ref</span> <span class="s">&quot;text&quot;</span>
                    <span class="ss">:value</span> <span class="p">(</span><span class="ss">:text</span> <span class="nv">app</span><span class="p">)</span>
                    <span class="ss">:onChange</span> <span class="o">#</span><span class="p">(</span><span class="nf">put!</span>
                                <span class="p">(</span><span class="ss">:string</span> <span class="nv">comm</span><span class="p">)</span>
                                <span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">om/get-node</span> <span class="nv">owner</span> <span class="s">&quot;text&quot;</span><span class="p">)</span>
                                    <span class="nv">.-value</span><span class="p">))})</span>
</code></pre></div>


<p>The element is actually only taking a single argument, though it looks like two.
<code>#js</code> is a reader literal for Clojurscript that transforms the following object
into literal JavaScript object. The map that we pass is setting some attributes
on the component. In this case, we want a text input that contains the value of
the <code>:text</code> key from our application state. We assign it the ref <code>text</code> so that
we can refer to it from the <code>onChange</code> callback via <code>om/get-node</code>.</p>

<p>This callback is really simple, and is one of the reasons why core.async is so
attractive. All it does is take the value of the <code>text</code> node and put it onto the
<code>string</code> channel.</p>

<p>If you&rsquo;ve been following along, then you should see the following:</p>

<div class='highlight example' id="ex2"> </div>

<p>The next step is to add in the text-size slider. First, let&rsquo;s add the size to
our application state:</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure">    <span class="p">(</span><span class="k">def </span><span class="nv">app-state</span> <span class="p">(</span><span class="nf">atom</span> <span class="p">{</span><span class="ss">:text</span> <span class="s">&quot;Some Text&quot;</span>
                          <span class="ss">:size</span> <span class="mi">15</span><span class="p">}))</span>
</code></pre></div>


<p>Next we&rsquo;ll create another channel for manipulating this size:</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure">    <span class="nv">om/IInitState</span>
    <span class="p">(</span><span class="nf">init-state</span> <span class="p">[</span><span class="nv">this</span><span class="p">]</span>
      <span class="p">{</span><span class="ss">:comm</span> <span class="p">{</span><span class="ss">:string</span> <span class="p">(</span><span class="nf">chan</span><span class="p">)</span>
              <span class="ss">:size</span> <span class="p">(</span><span class="nf">chan</span><span class="p">)}})</span>
</code></pre></div>


<p>We&rsquo;ll create another go block to update <code>:size</code> whenever we get a value off of
this channel:</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure">    <span class="nv">om/IWillMount</span>
    <span class="p">(</span><span class="nf">will-mount</span> <span class="p">[</span><span class="nv">this</span><span class="p">]</span>
      <span class="p">(</span><span class="k">let </span><span class="p">[{</span><span class="ss">:keys</span> <span class="p">[</span><span class="nv">string</span> <span class="nv">size</span><span class="p">]</span> <span class="ss">:as</span> <span class="nv">comm</span><span class="p">}</span> <span class="p">(</span><span class="nf">om/get-state</span> <span class="nv">owner</span> <span class="ss">:comm</span><span class="p">)]</span>
        <span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="nf">while</span> <span class="nv">true</span>
              <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">value</span> <span class="p">(</span><span class="nf">&lt;!</span> <span class="nv">string</span><span class="p">)]</span>
                <span class="p">(</span><span class="nf">om/transact!</span> <span class="nv">app</span> <span class="ss">:text</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="nv">value</span><span class="p">)))))</span>
        <span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="nf">while</span> <span class="nv">true</span>
              <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">value</span> <span class="p">(</span><span class="nf">&lt;!</span> <span class="nv">size</span><span class="p">)]</span>
                <span class="p">(</span><span class="nf">om/transact!</span> <span class="nv">app</span> <span class="ss">:size</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="nv">value</span><span class="p">)))))))</span>
</code></pre></div>


<p>And then we&rsquo;ll add the input. Since we&rsquo;re getting the value off in the input
in a similar way as before, I created a small helper to do this. I would place
this function at the top of your source file, underneath the atom:</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure">    <span class="p">(</span><span class="kd">defn </span><span class="nv">get-value</span> <span class="p">[</span><span class="nv">owner</span> <span class="nv">ref</span><span class="p">]</span>
      <span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">om/get-node</span> <span class="nv">owner</span> <span class="nv">ref</span><span class="p">)</span>
          <span class="nv">.-value</span><span class="p">))</span>
</code></pre></div>


<div class="highlight"><pre><code class="language-clojure" data-lang="clojure">    <span class="p">(</span><span class="nf">dom/div</span> <span class="nv">nil</span>
            <span class="p">(</span><span class="nf">dom/input</span> <span class="o">#</span><span class="nv">js</span> <span class="p">{</span><span class="ss">:type</span> <span class="s">&quot;range&quot;</span>
                            <span class="ss">:min</span> <span class="mi">10</span>
                            <span class="ss">:max</span> <span class="mi">50</span>
                            <span class="ss">:step</span> <span class="mf">0.2</span>
                            <span class="ss">:ref</span> <span class="s">&quot;size&quot;</span>
                            <span class="ss">:value</span> <span class="p">(</span><span class="ss">:size</span> <span class="nv">app</span><span class="p">)</span>
                            <span class="ss">:onChange</span> <span class="o">#</span><span class="p">(</span><span class="nf">put!</span>
                                        <span class="p">(</span><span class="ss">:size</span> <span class="nv">comm</span><span class="p">)</span>
                                        <span class="p">(</span><span class="nf">get-value</span> <span class="nv">owner</span> <span class="s">&quot;size&quot;</span><span class="p">))})</span>
            <span class="p">(</span><span class="nf">dom/label</span> <span class="nv">nil</span> <span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="ss">:size</span> <span class="nv">app</span><span class="p">)</span> <span class="s">&quot;px&quot;</span><span class="p">)))</span>
</code></pre></div>


<p>Note that you may want to update the text input as well.</p>

<p>Finally, we want to modify our <code>div</code> to have it&rsquo;s font-size restyled whenever
this changes. Right now it looks like this:</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure">    <span class="p">(</span><span class="nf">dom/div</span> <span class="nv">nil</span> <span class="p">(</span><span class="ss">:text</span> <span class="nv">app</span><span class="p">))</span>
</code></pre></div>


<p>Change it to this:</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure">    <span class="p">(</span><span class="nf">dom/div</span> <span class="o">#</span><span class="nv">js</span> <span class="p">{</span><span class="ss">:style</span> <span class="o">#</span><span class="nv">js</span> <span class="p">{</span><span class="ss">:font-size</span> <span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="ss">:size</span> <span class="nv">app</span><span class="p">)</span> <span class="s">&quot;px&quot;</span><span class="p">)}}</span>
          <span class="p">(</span><span class="ss">:text</span> <span class="nv">app</span><span class="p">))</span>
</code></pre></div>


<p>Again, <code>#js</code> turns the following object into a JavaScript object. It&rsquo;s shallow,
so we need to do it twice to set <code>:style</code> correctly.</p>

<p>You should see this now:</p>

<div class='highlight example' id="ex3"> </div>

<p>Now for the color sliders. First, we&rsquo;ll add in the new state:</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure">    <span class="p">(</span><span class="k">def </span><span class="nv">app-state</span> <span class="p">(</span><span class="nf">atom</span> <span class="p">{</span><span class="ss">:text</span> <span class="s">&quot;Some Text&quot;</span>
                          <span class="ss">:size</span> <span class="mi">15</span>
                          <span class="ss">:colors</span> <span class="p">{</span><span class="ss">:red</span> <span class="mi">0</span>
                                   <span class="ss">:green</span> <span class="mi">0</span>
                                   <span class="ss">:blue</span> <span class="mi">0</span><span class="p">}}))</span>
</code></pre></div>


<p>As in the React widget, we&rsquo;ll create a more general <code>color-slider</code>:</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure">    <span class="p">(</span><span class="kd">defn </span><span class="nv">color-slider</span> <span class="p">[</span><span class="nv">colors</span> <span class="nv">owner</span> <span class="p">{</span><span class="ss">:keys</span> <span class="p">[</span><span class="nv">label</span> <span class="nv">onChange</span> <span class="nv">color-key</span><span class="p">]}]</span>
      <span class="p">(</span><span class="nf">reify</span>
        <span class="nv">om/IRenderState</span>
        <span class="p">(</span><span class="nf">render-state</span> <span class="p">[</span><span class="nv">this</span> <span class="p">{</span><span class="ss">:keys</span> <span class="p">[</span><span class="nv">comm</span><span class="p">]}]</span>
          <span class="p">(</span><span class="nf">dom/div</span> <span class="nv">nil</span>
                   <span class="p">(</span><span class="nf">dom/input</span> <span class="o">#</span><span class="nv">js</span> <span class="p">{</span><span class="ss">:type</span> <span class="s">&quot;range&quot;</span>
                                   <span class="ss">:min</span> <span class="mi">0</span>
                                   <span class="ss">:max</span> <span class="mi">255</span>
                                   <span class="ss">:step</span> <span class="mi">1</span>
                                   <span class="ss">:ref</span> <span class="s">&quot;color&quot;</span>
                                   <span class="ss">:value</span> <span class="p">(</span><span class="nf">color-key</span> <span class="nv">colors</span><span class="p">)</span>
                                   <span class="ss">:onChange</span> <span class="o">#</span><span class="p">(</span><span class="nf">onChange</span> <span class="nv">color-key</span> <span class="nv">owner</span><span class="p">)})</span>
                   <span class="p">(</span><span class="nf">dom/label</span> <span class="nv">nil</span> <span class="p">(</span><span class="nb">str </span><span class="nv">label</span> <span class="s">&quot;: &quot;</span> <span class="p">(</span><span class="nf">color-key</span> <span class="nv">colors</span><span class="p">)))))))</span>
</code></pre></div>


<p>The important bit here is extra map of attributes we&rsquo;ll be passing to this
component. We&rsquo;re going to give it a label, a color key to pull from the
application state, and an onChange function.</p>

<p>Next we&rsquo;ll create a channel for the changing colors:</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure">    <span class="nv">om/IInitState</span>
    <span class="p">(</span><span class="nf">init-state</span> <span class="p">[</span><span class="nv">this</span><span class="p">]</span>
      <span class="p">{</span><span class="ss">:comm</span> <span class="p">{</span><span class="ss">:string</span> <span class="p">(</span><span class="nf">chan</span><span class="p">)</span>
              <span class="ss">:size</span> <span class="p">(</span><span class="nf">chan</span><span class="p">)</span>
              <span class="ss">:colors</span> <span class="p">(</span><span class="nf">chan</span><span class="p">)}})</span>
</code></pre></div>


<p>And a go block:
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure">    <span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="nf">while</span> <span class="nv">true</span>
          <span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">c</span> <span class="nv">value</span><span class="p">]</span> <span class="p">(</span><span class="nf">&lt;!</span> <span class="nv">colors</span><span class="p">)]</span>
            <span class="p">(</span><span class="nf">om/update!</span> <span class="nv">app</span> <span class="nv">assoc-in</span> <span class="p">[</span><span class="ss">:colors</span> <span class="nv">c</span><span class="p">]</span> <span class="nv">value</span><span class="p">))))))</span>
</code></pre></div>
</p>

<p>This looks slightly different than the previous go blocks because we&rsquo;re dealing
with a map of colors in the application state instead of a straight value.</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure">    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">putfn</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">k</span> <span class="nv">o</span><span class="p">]</span>
                 <span class="p">(</span><span class="nf">put!</span> <span class="p">(</span><span class="ss">:colors</span> <span class="nv">comm</span><span class="p">)</span> <span class="p">[</span><span class="nv">k</span> <span class="p">(</span><span class="nf">get-value</span> <span class="nv">o</span> <span class="s">&quot;color&quot;</span><span class="p">)]))]</span>
        <span class="p">(</span><span class="nb">apply </span><span class="nv">dom/div</span> <span class="nv">nil</span>
             <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[[</span><span class="nv">label</span> <span class="nv">color-key</span><span class="p">]]</span>
                    <span class="p">(</span><span class="nf">om/build</span> <span class="nv">color-slider</span>
                              <span class="p">(</span><span class="ss">:colors</span> <span class="nv">app</span><span class="p">)</span>
                              <span class="p">{</span><span class="ss">:opts</span> <span class="p">{</span><span class="ss">:label</span> <span class="nv">label</span>
                                      <span class="ss">:color-key</span> <span class="nv">color-key</span>
                                      <span class="ss">:onChange</span> <span class="nv">putfn</span><span class="p">}}))</span>
                  <span class="p">[[</span><span class="s">&quot;Red&quot;</span> <span class="ss">:red</span><span class="p">]</span> <span class="p">[</span><span class="s">&quot;Green&quot;</span> <span class="ss">:green</span><span class="p">]</span> <span class="p">[</span><span class="s">&quot;Blue&quot;</span> <span class="ss">:blue</span><span class="p">]])))</span>
</code></pre></div>


<p>Next we&rsquo;ll add the inputs right below the text size slider. We use some
high level functions here to avoid having to write three calls to <code>om/build</code>.</p>

<p>Finally we can modify the <code>div</code> to re-color our text:</p>

<div class="highlight"><pre><code class="language-clojure" data-lang="clojure">    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">size</span> <span class="p">(</span><span class="ss">:size</span> <span class="nv">app</span><span class="p">)</span>
          <span class="nv">text</span> <span class="p">(</span><span class="ss">:text</span> <span class="nv">app</span><span class="p">)</span>
          <span class="p">{</span><span class="ss">:keys</span> <span class="p">[</span><span class="nv">red</span> <span class="nv">green</span> <span class="nv">blue</span><span class="p">]}</span> <span class="p">(</span><span class="ss">:colors</span> <span class="nv">app</span><span class="p">)]</span>
     <span class="p">(</span><span class="nf">dom/div</span> <span class="o">#</span><span class="nv">js</span> <span class="p">{</span><span class="ss">:style</span> <span class="o">#</span><span class="nv">js</span> <span class="p">{</span><span class="ss">:font-size</span> <span class="p">(</span><span class="nb">str </span><span class="nv">size</span> <span class="s">&quot;px&quot;</span><span class="p">)</span>
                               <span class="ss">:color</span> <span class="p">(</span><span class="nb">str </span><span class="s">&quot;rgb(&quot;</span> <span class="nv">red</span> <span class="s">&quot;,&quot;</span> <span class="nv">green</span> <span class="s">&quot;,&quot;</span> <span class="nv">blue</span> <span class="s">&quot;)&quot;</span><span class="p">)}}</span>
              <span class="nv">text</span><span class="p">))))))</span>
</code></pre></div>


<p>Here is the final product, for the second time:
<div class='highlight example' id="final"> </div></p>

<p>The full source for this example can be found <a href="https://gist.github.com/mcramm/8755952">here</a>.</p>

<p>Om is still very new, and changing rapidly. If you&rsquo;re interested, then I
recommend running through the
<a href="https://github.com/swannodette/om/wiki/Tutorial">Tutorial</a> in LightTable.</p>

<script src="/js/om-intro.js" type="text/javascript"></script>
            

        </section>

        
    </div>
</article>

<footer class="site-footer">
    <div class="container">
        <nav>
            <a href="/" class="home">About</a>
            <a href="/post" class="post">Posts</a>
        </nav>
        
        <nav class="social">
            
            <a href="https://twitter.com/cramm" title="Follow on Twitter" target="_blank"><i class="icon icon-twitter black"></i></a>
            
            
            <a href="https://github.com/mcramm" title="Follow on Github" target="_blank"><i class="icon icon-github black"></i></a>
            
            <a href="/index.xml" title="RSS Feed">
                <i class="icon icon-rss black"></i>
            </a>
        </nav>
    </div>
</footer>
<script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script type="text/javascript" src="/js/main.js"></script>

<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

<script>
    (function(d, t) {
        var g = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        g.src = '//hnbutton.appspot.com/static/hn.min.js';
        s.parentNode.insertBefore(g, s);
    }(document, 'script'));
</script>







  

</body>
</html>

